# GitLab CI/CD Setup Guide

This document explains how to configure GitLab CI/CD for deploying to AWS ECS via CodeBuild.

## Overview

The CI/CD pipeline consists of:
1. **GitLab CI** - Runs tests, linting, and triggers AWS CodeBuild
2. **AWS CodeBuild** - Builds Docker images and deploys to ECS
3. **AWS ECS** - Runs the containerized application

## GitLab CI/CD Variables

Configure the following variables in GitLab under **Settings > CI/CD > Variables**:

### AWS Credentials
- `CI_AWS_ACCESS_KEY_ID` - AWS access key ID (masked, protected)
- `CI_AWS_SECRET_ACCESS_KEY` - AWS secret access key (masked, protected)
- `CI_AWS_REGION` - AWS region (e.g., `us-east-1`)

### CodeBuild Project Names
- `CI_CODEBUILD_PROJECT_DEV` - CodeBuild project name for dev environment
- `CI_CODEBUILD_PROJECT_STAGE` - CodeBuild project name for stage environment
- `CI_CODEBUILD_PROJECT_PROD` - CodeBuild project name for prod environment

### ECS Configuration - DEV
- `CI_ECS_CLUSTER_DEV` - ECS cluster name for dev
- `CI_ECS_SERVICE_DEV` - ECS service name for dev
- `CI_ECS_TASK_DEFINITION_DEV` - ECS task definition family name for dev
- `CI_ECR_REPOSITORY_DEV` - ECR repository name for dev (e.g., `nest-app-dev`)
- `CI_ENVIRONMENT_URL_DEV` - Application URL for dev environment (used for health checks)

### ECS Configuration - STAGE
- `CI_ECS_CLUSTER_STAGE` - ECS cluster name for stage
- `CI_ECS_SERVICE_STAGE` - ECS service name for stage
- `CI_ECS_TASK_DEFINITION_STAGE` - ECS task definition family name for stage
- `CI_ECR_REPOSITORY_STAGE` - ECR repository name for stage (e.g., `nest-app-stage`)
- `CI_ENVIRONMENT_URL_STAGE` - Application URL for stage environment (used for health checks)

### ECS Configuration - PROD
- `CI_ECS_CLUSTER_PROD` - ECS cluster name for prod
- `CI_ECS_SERVICE_PROD` - ECS service name for prod
- `CI_ECS_TASK_DEFINITION_PROD` - ECS task definition family name for prod
- `CI_ECR_REPOSITORY_PROD` - ECR repository name for prod (e.g., `nest-app-prod`)
- `CI_ENVIRONMENT_URL_PROD` - Application URL for prod environment (used for health checks)

### Database Configuration (Optional)
**Note:** It's recommended to use AWS Systems Manager Parameter Store for database credentials instead of GitLab variables for better security.

For each environment (DEV/STAGE/PROD), you can optionally set:
- `CI_DB_HOST_{ENV}` - Database host
- `CI_DB_PORT_{ENV}` - Database port (default: 3306)
- `CI_DB_USERNAME_{ENV}` - Database username
- `CI_DB_PASSWORD_{ENV}` - Database password (masked, protected)
- `CI_DB_NAME_{ENV}` - Database name

Example for DEV:
- `CI_DB_HOST_DEV`
- `CI_DB_PORT_DEV`
- `CI_DB_USERNAME_DEV`
- `CI_DB_PASSWORD_DEV`
- `CI_DB_NAME_DEV`

### Health Check Configuration (Optional)
- `CI_HEALTH_CHECK_URL_DEV` - Direct health check URL for dev (e.g., `https://dev.example.com/api/v1/health`)
- `CI_HEALTH_CHECK_URL_STAGE` - Direct health check URL for stage
- `CI_HEALTH_CHECK_URL_PROD` - Direct health check URL for prod
- `CI_HEALTH_CHECK_MAX_RETRIES` - Maximum health check retry attempts (default: 30)
- `CI_HEALTH_CHECK_RETRY_INTERVAL` - Seconds between health check retries (default: 10)

**Note:** If `CI_HEALTH_CHECK_URL_{ENV}` is not set, the health check will use `CI_ENVIRONMENT_URL_{ENV}` with `/api/v1/health` appended, or attempt to auto-detect from the ECS load balancer.

## AWS CodeBuild Setup

Each environment (dev/stage/prod) requires a CodeBuild project. The CodeBuild project should:

1. **Source**: Use GitLab as source (or S3 if you push artifacts)
2. **Environment**: 
   - Use Docker image (e.g., `aws/codebuild/standard:7.0`)
   - Enable Privileged mode (for Docker builds)
3. **Buildspec**: Use a `buildspec.yml` file in the repository root
4. **Service Role**: IAM role with permissions for:
   - ECR (push/pull images)
   - ECS (update services, register task definitions)
   - CloudWatch Logs (write logs)

### Sample buildspec.yml

Create a `buildspec.yml` file in your repository root:

```yaml
version: 0.2

phases:
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
      - REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPOSITORY
      - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - IMAGE_TAG=${IMAGE_TAG:-$COMMIT_HASH}
  build:
    commands:
      - echo Build started on `date`
      - echo Building the Docker image...
      - docker build --target $DOCKER_TARGET -t $REPOSITORY_URI:$IMAGE_TAG .
      - docker tag $REPOSITORY_URI:$IMAGE_TAG $REPOSITORY_URI:latest
  post_build:
    commands:
      - echo Build completed on `date`
      - echo Pushing the Docker images...
      - docker push $REPOSITORY_URI:$IMAGE_TAG
      - docker push $REPOSITORY_URI:latest
      - echo Writing image definitions file...
      - printf '[{"name":"%s","imageUri":"%s"}]' $ECS_SERVICE $REPOSITORY_URI:$IMAGE_TAG > imagedefinitions.json
      - echo Updating ECS service...
      - aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --force-new-deployment --region $AWS_DEFAULT_REGION
      - echo Deployment completed on `date`
artifacts:
  files:
    - imagedefinitions.json
```

### CodeBuild Environment Variables

Configure these in each CodeBuild project:

- `AWS_DEFAULT_REGION` - AWS region
- `AWS_ACCOUNT_ID` - Your AWS account ID
- `ECS_CLUSTER` - ECS cluster name (will be overridden by GitLab CI)
- `ECS_SERVICE` - ECS service name (will be overridden by GitLab CI)
- `ECS_TASK_DEFINITION` - ECS task definition family (will be overridden by GitLab CI)
- `ECR_REPOSITORY` - ECR repository name (will be overridden by GitLab CI)
- `DOCKER_TARGET` - Docker build target (will be overridden by GitLab CI)
- `IMAGE_TAG` - Docker image tag (will be overridden by GitLab CI)
- `ENVIRONMENT` - Environment name (dev/stage/prod, will be overridden by GitLab CI)

### Database Migrations

The pipeline automatically runs database migrations during deployment if database credentials are configured. Migrations run:
- After the Docker image is built and pushed to ECR
- Before the ECS service is updated
- Using the same Docker image that will be deployed

**Configuration Options:**

1. **AWS Systems Manager Parameter Store (Recommended)**
   - Configure in `buildspec.yml` under `parameter-store`
   - Format: `/nest-monolit-starter/${ENVIRONMENT}/database/{parameter}`
   - More secure, credentials not stored in GitLab

2. **GitLab CI/CD Variables**
   - Set `CI_DB_HOST_{ENV}`, `CI_DB_USERNAME_{ENV}`, `CI_DB_PASSWORD_{ENV}`, etc.
   - Less secure but simpler for testing

**Migration Failure Handling:**
- By default, deployment fails if migrations fail (recommended for production)
- Migrations are skipped if database credentials are not configured

### Health Checks

The pipeline performs automatic health checks after deployment to ensure the application is running correctly. Health checks:
- Run after ECS service stabilizes
- Check the `/api/v1/health` endpoint
- Validate response contains `"status": "ok"`
- Retry up to 30 times (configurable) with 10-second intervals
- Fail deployment if health check doesn't pass

**Health Check URL Detection:**
1. Uses `CI_HEALTH_CHECK_URL_{ENV}` if set (explicit URL)
2. Falls back to `CI_ENVIRONMENT_URL_{ENV}` + `/api/v1/health`
3. Attempts auto-detection from ECS load balancer (if configured)
4. Skips health check if URL cannot be determined (with warning)

## IAM Permissions

The IAM role used by CodeBuild needs the following permissions:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ecr:GetAuthorizationToken",
        "ecr:BatchCheckLayerAvailability",
        "ecr:GetDownloadUrlForLayer",
        "ecr:BatchGetImage",
        "ecr:PutImage",
        "ecr:InitiateLayerUpload",
        "ecr:UploadLayerPart",
        "ecr:CompleteLayerUpload"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "ecs:UpdateService",
        "ecs:DescribeServices",
        "ecs:DescribeTaskDefinition",
        "ecs:RegisterTaskDefinition",
        "ecs:ListTasks",
        "ecs:DescribeTasks"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "codebuild:StartBuild",
        "codebuild:BatchGetBuilds"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "elbv2:DescribeLoadBalancers",
        "elbv2:DescribeTargetGroups"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "ssm:GetParameter",
        "ssm:GetParameters",
        "ssm:GetParametersByPath"
      ],
      "Resource": "arn:aws:ssm:*:*:parameter/nest-monolit-starter/*"
    }
  ]
}
```

**Additional Permissions:**
- `elbv2:DescribeLoadBalancers` and `elbv2:DescribeTargetGroups` - Required for health check auto-detection
- `ssm:GetParameter*` - Required if using AWS Systems Manager Parameter Store for database credentials

## GitLab Runner Requirements

The GitLab runner needs:
- Docker executor (for build/test stages)
- AWS CLI installed (or use the `amazon/aws-cli` image as shown in deploy jobs)

## Pipeline Flow

1. **Build Stage**: Installs dependencies and builds the application
2. **Test Stage**: Runs linting and unit tests (E2E tests optional)
3. **Deploy Stage**: 
   - Triggers AWS CodeBuild
   - CodeBuild builds Docker image
   - CodeBuild pushes to ECR
   - CodeBuild runs database migrations (if configured)
   - CodeBuild updates ECS service
   - CodeBuild waits for service to stabilize
   - CodeBuild performs health check (if configured)

## Branch Strategy

- `dev` branch → Deploys to DEV environment (manual trigger)
- `stage` branch → Deploys to STAGE environment (manual trigger)
- `main`/`master` branch → Deploys to PROD environment (manual trigger)

## Manual Deployment

All deployments are set to `when: manual` for safety. To deploy:
1. Push code to the appropriate branch
2. Go to GitLab CI/CD > Pipelines
3. Click the play button (▶️) next to the deploy job

## Troubleshooting

### CodeBuild fails to start
- Check AWS credentials in GitLab CI/CD variables
- Verify CodeBuild project names are correct
- Ensure IAM permissions allow `codebuild:StartBuild`

### CodeBuild succeeds but ECS doesn't update
- Check ECS cluster/service names
- Verify CodeBuild IAM role has ECS permissions
- Check CloudWatch logs for CodeBuild project

### Docker build fails in CodeBuild
- Ensure CodeBuild environment has Privileged mode enabled
- Verify Dockerfile is correct
- Check ECR repository exists and is accessible

### Database migrations fail
- Verify database credentials are configured (Parameter Store or GitLab variables)
- Check database connectivity from CodeBuild environment
- Review migration logs in CodeBuild output
- Ensure database user has permissions to run migrations
- Check that migrations are included in the Docker image (`src/migrations/` directory)

### Health check fails
- Verify `CI_HEALTH_CHECK_URL_{ENV}` or `CI_ENVIRONMENT_URL_{ENV}` is set correctly
- Check that the health endpoint `/api/v1/health` is accessible
- Ensure load balancer is configured if using auto-detection
- Verify ECS service is actually running and healthy
- Check application logs for errors
- Increase `CI_HEALTH_CHECK_MAX_RETRIES` if service takes longer to start

### Health check skipped
- This is normal if health check URL cannot be determined
- Set `CI_HEALTH_CHECK_URL_{ENV}` explicitly to enable health checks
- Or configure `CI_ENVIRONMENT_URL_{ENV}` for automatic URL construction

